#!/usr/bin/env python3
import os
import shutil
import sys
import time
import hashlib
import tempfile
import subprocess
import argparse
import shlex
import threading
import urllib.error
import urllib.request
import yaml
from typing import Dict, List, Any, Optional, Tuple

try:
    import curses as _curses
except Exception:  # pragma: no cover - platform dependent
    _curses = None

try:
    import pexpect as _pexpect
except Exception:  # pragma: no cover - platform dependent
    _pexpect = None

try:
    import termios as _termios
except Exception:  # pragma: no cover - platform dependent
    _termios = None

CURSES_AVAILABLE = _curses is not None
PEXPECT_AVAILABLE = _pexpect is not None

curses: Any = _curses
pexpect: Any = _pexpect

NON_INTERACTIVE_INTERACT_EXCEPTIONS: Tuple[type, ...] = (OSError, ValueError)
if PEXPECT_AVAILABLE:
    NON_INTERACTIVE_INTERACT_EXCEPTIONS = (
        *NON_INTERACTIVE_INTERACT_EXCEPTIONS,
        pexpect.EOF,
    )
if _termios is not None:
    NON_INTERACTIVE_INTERACT_EXCEPTIONS = (
        *NON_INTERACTIVE_INTERACT_EXCEPTIONS,
        _termios.error,
    )

ANSI_PRIMARY = "\033[38;5;67m"
ANSI_MUTED = "\033[38;5;244m"
ANSI_SUCCESS = "\033[38;5;108m"
ANSI_ERROR = "\033[38;5;131m"
ANSI_WARN = "\033[38;5;214m"
ANSI_BOLD = "\033[1m"
ANSI_RESET = "\033[0m"

HEADER_TITLE = "commands-wrapper"
PRIMARY_WRAPPER = "commands-wrapper"
SHORT_ALIAS = "cw"
LEGACY_ALIAS = "command-wrapper"

DEFAULT_UPDATE_TARBALL_URL = "https://github.com/omnious0o0/commands-wrapper/archive/refs/heads/main.tar.gz"
UPDATE_TARBALL_URL = os.environ.get("COMMANDS_WRAPPER_UPDATE_URL", "").strip() or DEFAULT_UPDATE_TARBALL_URL


_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
WRAPPER_MARKER = "COMMANDS-WRAPPER-GENERATED"


def _script_bin_dir(platform_name: Optional[str] = None) -> str:
    import site
    import sysconfig

    plat = platform_name or os.name
    if plat == os.name:
        in_venv = getattr(sys, 'base_prefix', sys.prefix) != sys.prefix
        scripts_dir: Optional[str] = None
        if in_venv:
            scripts_dir = sysconfig.get_path('scripts')
        else:
            user_scheme = f'{plat}_user'
            if user_scheme in sysconfig.get_scheme_names():
                scripts_dir = sysconfig.get_path('scripts', scheme=user_scheme)

        if scripts_dir:
            return os.path.abspath(scripts_dir)

    suffix = 'Scripts' if plat == 'nt' else 'bin'
    user_base = site.USER_BASE or os.path.expanduser('~')
    return os.path.join(user_base, suffix)


def _user_config_dir(platform_name: Optional[str] = None) -> str:
    plat = platform_name or os.name
    if plat == 'nt':
        base = os.environ.get('APPDATA') or os.path.expanduser('~')
        return os.path.join(base, 'commands-wrapper')

    xdg = os.environ.get('XDG_CONFIG_HOME')
    if xdg:
        return os.path.join(os.path.expanduser(xdg), 'commands-wrapper')
    return os.path.join(os.path.expanduser('~'), '.config', 'commands-wrapper')


def _legacy_config_dir() -> str:
    return os.path.join(os.path.expanduser('~'), '.commands-wrapper')


def _command_file_candidates(root: str) -> List[str]:
    return [os.path.join(root, 'commands.yaml'), os.path.join(root, 'commands.yml')]


def _preferred_command_file_for_write() -> str:
    cwd = os.getcwd()

    for candidate in _command_file_candidates(cwd):
        if os.path.isfile(candidate):
            return candidate

    global_candidates = [
        *_command_file_candidates(_user_config_dir()),
        *_command_file_candidates(_legacy_config_dir()),
    ]

    for candidate in global_candidates:
        if os.path.isfile(candidate):
            return candidate

    return global_candidates[0]


def _shell_name() -> str:
    if os.name == 'nt':
        return os.environ.get('COMSPEC', 'cmd.exe')
    return os.environ.get('SHELL', '/bin/sh')


def _has_tui_support() -> bool:
    return CURSES_AVAILABLE and sys.stdin.isatty() and sys.stdout.isatty()


def _cmd_quote(value: str) -> str:
    return '"' + value.replace('"', '""') + '"'


def _init_colors():
    if not curses.has_colors():
        return

    try:
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(3, 244, -1)
        curses.init_pair(4, 108, -1)
        curses.init_pair(5, 131, -1)
        curses.init_pair(6, 67, -1)
    except curses.error:
        pass

SEL = lambda: curses.color_pair(1) | curses.A_BOLD
DIM = lambda: curses.color_pair(3)
OK  = lambda: curses.color_pair(4) | curses.A_BOLD
ERR = lambda: curses.color_pair(5) | curses.A_BOLD
HDR = lambda: curses.color_pair(6) | curses.A_BOLD

def _addstr(win, y, x, text, attr=0):
    h, w = win.getmaxyx()
    if y < 0 or y >= h or x < 0 or x >= w:
        return
    max_len = w - x - 1
    if max_len <= 0:
        return
    try:
        win.addstr(y, x, text[:max_len], attr)
    except curses.error:
        pass

def _draw_hline(win, y, x, n, char='─'):
    h, w = win.getmaxyx()
    if y < 0 or y >= h or x < 0 or x >= w:
        return
    n = min(n, w - x)
    if n > 0:
        try:
            win.addstr(y, x, char * n)
        except curses.error:
            pass

def _draw_field_box_pad(pad, y, x, w, h, title: str, active: bool = False):
    attr = HDR() if active else DIM()
    try:
        pad.attron(attr)
        pad.addstr(y, x, "┌")
        pad.addstr(y, x + w - 1, "┐")
        pad.addstr(y + h - 1, x, "└")
        pad.addstr(y + h - 1, x + w - 1, "┘")
        _draw_hline(pad, y, x + 1, w - 2, '─')
        _draw_hline(pad, y + h - 1, x + 1, w - 2, '─')
        for i in range(1, h - 1):
            pad.addstr(y + i, x, "│")
            pad.addstr(y + i, x + w - 1, "│")
        pad.attroff(attr)
        _addstr(pad, y, x + 2, f" {title} ", HDR() if active else DIM())
    except curses.error:
        pass


def _draw_header(win, title: str, compact: bool = False):
    win.erase()
    h, _ = win.getmaxyx()
    y = 1
    label = HEADER_TITLE.upper() if not compact and h > 18 else HEADER_TITLE
    _addstr(win, y, 2, f" {label} ", HDR())
    y += 2

    _addstr(win, y, 4, title, curses.A_BOLD)
    _draw_hline(win, y + 1, 4, len(title))
    return y + 3


def _read_esc_followup_key(win, wait_seconds: float = 0.04) -> int:
    deadline = time.monotonic() + wait_seconds
    win.nodelay(True)
    try:
        while time.monotonic() < deadline:
            key = win.getch()
            if key != -1:
                return key
            time.sleep(0.005)
    finally:
        win.nodelay(False)
    return -1


def _handle_escape_in_form(win, fields: List['Field'], focus: int) -> bool:
    nk = _read_esc_followup_key(win)
    if nk == -1:
        return False

    if nk in (10, 13):  # Alt+Enter: insert newline in multiline fields
        f = fields[focus]
        if f.multiline:
            p, n = f.lines[f.cur_y][:f.cur_x], f.lines[f.cur_y][f.cur_x:]
            f.lines[f.cur_y] = p
            f.lines.insert(f.cur_y + 1, n)
            f.cur_y += 1
            f.cur_x = 0
        return True

    try:
        curses.ungetch(nk)
    except curses.error:
        pass
    return True


def menu(win, title: str, options: List[str], status: str = "") -> Optional[int]:
    """Arrow-key navigable menu. Returns selected index or None if cancelled."""
    if not options:
        return None

    cur = 0
    top = 0
    while True:
        y_offset = _draw_header(win, title)
        h, w = win.getmaxyx()
        visible_rows = max(1, h - y_offset - 3)

        if cur < top:
            top = cur
        elif cur >= top + visible_rows:
            top = cur - visible_rows + 1

        item_width = max(24, min(w - 8, max((len(opt) for opt in options), default=0) + 6))

        bottom = min(len(options), top + visible_rows)
        for row_index, i in enumerate(range(top, bottom)):
            row = y_offset + row_index
            opt = options[i]
            if i == cur:
                _addstr(win, row, 4, f"  {opt}  ".ljust(item_width), SEL())
            else:
                _addstr(win, row, 6, opt, DIM())

        if top > 0:
            _addstr(win, y_offset - 1, w - 5, "^", DIM())
        if bottom < len(options):
            _addstr(win, y_offset + visible_rows, w - 5, "v", DIM())

        hint = " ↑↓/j/k navigate   ENTER select   ESC back "
        _addstr(win, h - 2, 2, hint, DIM())
        if status:
            status_attr = ERR()
            if status.startswith("OK:"):
                status_attr = OK()
            elif status.startswith("WARN:"):
                status_attr = HDR()
            elif status.startswith("INFO:"):
                status_attr = DIM()
            _addstr(win, h - 3, 2, status, status_attr)

        win.refresh()
        key = win.getch()

        if key == 27:  # ESC or Alt+key
            nk = _read_esc_followup_key(win)
            if nk == -1:
                return None
            key = nk

        if key in (curses.KEY_UP, ord('k'), ord('K')):
            cur = (cur - 1) % len(options)
        elif key in (curses.KEY_DOWN, ord('j'), ord('J')):
            cur = (cur + 1) % len(options)
        elif key in (curses.KEY_ENTER, ord('\n'), ord('\r')):
            return cur
        elif key in (ord('q'), ord('Q')):
            return None


class Field:
    def __init__(self, key: str, label: str, value: str = "", multiline: bool = False, box_h: int = 3):
        self.key = key
        self.label = label
        self.lines = [list(l) for l in str(value).split('\n')] if value else [[]]
        self.cur_y = 0
        self.cur_x = 0
        self.view_y = 0
        self.view_x = 0
        self.multiline = multiline
        self.box_h = box_h
        self.top_y = 0

    def get_value(self) -> str:
        return "\n".join("".join(l) for l in self.lines).strip()


def form_input(win, title: str, fields: List[Field]) -> Optional[Dict[str, str]]:
    """Adaptive form engine. Switches between unified and focused modes based on available height."""
    focus = 0
    form_scroll = 0

    prev_cursor: Optional[int] = None
    try:
        prev_cursor = curses.curs_set(0)
    except curses.error:
        prev_cursor = None
    try:
        while True:
            h, w = win.getmaxyx()
            sw = w - 8

            compact = (h < 26)
            y_hdr = _draw_header(win, title, compact=compact)
            avail_h = h - y_hdr - 3

            total_field_h = sum(f.box_h + 1 for f in fields)
            focus_mode = (total_field_h + 2 > avail_h)

            ph = max(total_field_h + 10, h * 2)
            pad = curses.newpad(ph, w)

            py = 0
            for i, f in enumerate(fields):
                f.top_y = py if not focus_mode else 0
                is_active = (i == focus)

                if focus_mode and not is_active:
                    continue

                box_h = f.box_h
                if focus_mode:
                    box_h = max(f.box_h, min(avail_h, 10))

                _draw_field_box_pad(pad, f.top_y, 4, sw, box_h, f.label, active=is_active)

                fw = sw - 4
                fh = box_h - 2

                if is_active:
                    if f.cur_y < f.view_y:
                        f.view_y = f.cur_y
                    elif f.cur_y >= f.view_y + fh:
                        f.view_y = f.cur_y - fh + 1
                    if f.cur_x < f.view_x:
                        f.view_x = f.cur_x
                    elif f.cur_x >= f.view_x + fw:
                        f.view_x = f.cur_x - fw + 1

                for r in range(fh):
                    ridx = f.view_y + r
                    if ridx < len(f.lines):
                        line_data = "".join(f.lines[ridx])[f.view_x : f.view_x + fw]
                        try:
                            pad.addstr(f.top_y + 1 + r, 6, line_data)
                        except curses.error:
                            pass
                        if f.view_x > 0:
                            pad.addch(f.top_y + 1 + r, 5, "<", DIM())
                        if len(f.lines[ridx]) > f.view_x + fw:
                            pad.addch(f.top_y + 1 + r, 6 + fw, ">", DIM())

                if is_active:
                    cursor_row = f.cur_y - f.view_y
                    cursor_col = f.cur_x - f.view_x
                    if 0 <= cursor_row < fh and 0 <= cursor_col < fw:
                        cursor_char = " "
                        if f.cur_y < len(f.lines):
                            line_chars = f.lines[f.cur_y]
                            if f.cur_x < len(line_chars):
                                cursor_char = line_chars[f.cur_x]
                        try:
                            pad.addch(
                                f.top_y + 1 + cursor_row,
                                6 + cursor_col,
                                cursor_char,
                                curses.A_REVERSE | curses.A_BOLD,
                            )
                        except curses.error:
                            pass

                if not focus_mode:
                    py += box_h + 1

            if not focus_mode:
                active_f = fields[focus]
                if active_f.top_y < form_scroll:
                    form_scroll = active_f.top_y
                elif active_f.top_y + active_f.box_h > form_scroll + avail_h:
                    form_scroll = active_f.top_y + active_f.box_h - avail_h
            else:
                form_scroll = 0

            win.refresh()
            r_y1, r_x1 = y_hdr, 0
            r_y2, r_x2 = max(r_y1, h - 3), w - 1
            try:
                pad.refresh(form_scroll, 0, r_y1, r_x1, r_y2, r_x2)
            except curses.error:
                pass

            h_hint = " TAB nav  ENTER next  Ctrl+S save  ESC cancel "
            if focus_mode:
                h_hint = f" [ FIELD {focus+1}/{len(fields)} ]  " + h_hint
            _addstr(win, h - 1, 2, h_hint.strip().center(w - 4), DIM())
            win.refresh()

            key = win.getch()

            if key == 19:  # Ctrl+S
                return {f.key: f.get_value() for f in fields}
            elif key == 27:  # ESC or Alt+key
                if not _handle_escape_in_form(win, fields, focus):
                    return None
                continue
            elif key == 9:  # Tab
                focus = (focus + 1) % len(fields)
            elif key == curses.KEY_BTAB:
                focus = (focus - 1) % len(fields)
            elif key == curses.KEY_UP:
                f = fields[focus]
                if f.cur_y > 0:
                    f.cur_y -= 1
                    f.cur_x = min(f.cur_x, len(f.lines[f.cur_y]))
                else:
                    focus = (focus - 1) % len(fields)
                    fields[focus].cur_y = len(fields[focus].lines) - 1
            elif key == curses.KEY_DOWN:
                f = fields[focus]
                if f.cur_y < len(f.lines) - 1:
                    f.cur_y += 1
                    f.cur_x = min(f.cur_x, len(f.lines[f.cur_y]))
                else:
                    focus = (focus + 1) % len(fields)
                    fields[focus].cur_y = 0
            elif key == curses.KEY_LEFT:
                f = fields[focus]
                if f.cur_x > 0:
                    f.cur_x -= 1
                elif f.cur_y > 0:
                    f.cur_y -= 1
                    f.cur_x = len(f.lines[f.cur_y])
            elif key == curses.KEY_RIGHT:
                f = fields[focus]
                if f.cur_x < len(f.lines[f.cur_y]):
                    f.cur_x += 1
                elif f.cur_y < len(f.lines) - 1:
                    f.cur_y += 1
                    f.cur_x = 0
            elif key in (10, 13, curses.KEY_ENTER):
                f = fields[focus]
                if focus == len(fields) - 1:
                    return {field.key: field.get_value() for field in fields}
                focus += 1
            elif key in (8, 127, curses.KEY_BACKSPACE):
                f = fields[focus]
                if f.cur_x > 0:
                    f.lines[f.cur_y].pop(f.cur_x - 1)
                    f.cur_x -= 1
                elif f.cur_y > 0:
                    ol = len(f.lines[f.cur_y - 1])
                    f.lines[f.cur_y - 1].extend(f.lines[f.cur_y])
                    f.lines.pop(f.cur_y)
                    f.cur_y -= 1
                    f.cur_x = ol
            elif key == curses.KEY_DC:
                f = fields[focus]
                if f.cur_x < len(f.lines[f.cur_y]):
                    f.lines[f.cur_y].pop(f.cur_x)
                elif f.cur_y < len(f.lines) - 1:
                    f.lines[f.cur_y].extend(f.lines[f.cur_y + 1])
                    f.lines.pop(f.cur_y + 1)
            elif 32 <= key <= 126:
                f = fields[focus]
                f.lines[f.cur_y].insert(f.cur_x, chr(key))
                f.cur_x += 1
    finally:
        if prev_cursor is not None:
            try:
                curses.curs_set(prev_cursor)
            except curses.error:
                pass


def _step_label(s: Dict) -> str:
    if 'command' in s:
        return f"  [COMMAND]  {s['command']}"
    if 'send' in s:
        return f"  [SEND]     {s['send']}"
    if 'press_key' in s:
        return f"  [KEY]      {s['press_key']}"
    if 'wait' in s:
        return f"  [WAIT]     {s['wait']}s"
    return "  [UNKNOWN]  unsupported step"


def _edit_existing_step(win, step: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    if 'command' in step:
        res = form_input(win, "Edit step", [Field("val", "Command:", value=str(step['command']), multiline=True, box_h=7)])
        if not res or not res["val"]:
            return None
        return {"command": res["val"]}

    if 'send' in step:
        res = form_input(win, "Edit step", [Field("val", "Text to send:", value=str(step['send']), multiline=True, box_h=5)])
        if not res or not res["val"]:
            return None
        return {"send": res["val"]}

    if 'press_key' in step:
        res = form_input(win, "Edit step", [Field("val", "Key (e.g. enter, tab, esc):", value=str(step['press_key']))])
        if not res or not res["val"]:
            return None
        return {"press_key": res["val"]}

    if 'wait' in step:
        res = form_input(win, "Edit step", [Field("val", "Duration (seconds):", value=str(step['wait']))])
        if not res or not res["val"]:
            return None

        wait_value = res["val"].strip()
        try:
            wait_duration = float(wait_value)
        except ValueError:
            return {"_error": "ERR: Wait must be a number"}

        if wait_duration < 0:
            return {"_error": "ERR: Wait must be non-negative"}

        return {"wait": wait_value}

    return None


def steps_editor(win, initial_steps: Optional[List[Dict]] = None) -> Optional[List[Dict]]:
    """Interactive step timeline editor. Returns updated steps or None if cancelled."""
    steps = list(initial_steps or [])
    status = ""

    while True:
        labels = [_step_label(s) for s in steps]
        labels.append("  + Add step")
        labels.append("  Save and return")

        choice = menu(win, "Step Timeline", labels, status)
        status = ""

        if choice is None:
            return None

        if choice == len(steps) + 1:
            return steps

        if choice == len(steps):
            stype = menu(win, "Step type", [
                "command   : run a shell command",
                "send      : type text into running process",
                "press_key : send a special key",
                "wait      : pause execution",
            ])
            if stype is None:
                continue

            title = "Add step"
            if stype == 0:
                res = form_input(win, title, [Field("val", "Command:", multiline=True, box_h=7)])
                if res and res["val"]:
                    steps.append({"command": res["val"]})
                    status = "OK: Step added"
            elif stype == 1:
                res = form_input(win, title, [Field("val", "Text to send:", multiline=True, box_h=5)])
                if res and res["val"]:
                    steps.append({"send": res["val"]})
                    status = "OK: Step added"
            elif stype == 2:
                res = form_input(win, title, [Field("val", "Key (e.g. enter, tab, esc):")])
                if res and res["val"]:
                    steps.append({"press_key": res["val"]})
                    status = "OK: Step added"
            elif stype == 3:
                res = form_input(win, title, [Field("val", "Duration (seconds):")])
                if res and res["val"]:
                    wait_value = res["val"].strip()
                    try:
                        wait_duration = float(wait_value)
                    except ValueError:
                        status = "ERR: Wait must be a number"
                        continue

                    if wait_duration < 0:
                        status = "ERR: Wait must be non-negative"
                        continue

                    steps.append({"wait": wait_value})
                    status = "OK: Step added"

        else:
            action = menu(win, f"Step {choice + 1}: {_step_label(steps[choice]).strip()}", [
                "Edit",
                "Move up",
                "Move down",
                "Delete",
                "Cancel",
            ])
            if action == 0:
                edited = _edit_existing_step(win, steps[choice])
                if edited is None:
                    continue
                if "_error" in edited:
                    status = str(edited["_error"])
                    continue
                steps[choice] = edited
                status = "OK: Step updated"
            elif action == 1 and choice > 0:
                steps[choice], steps[choice - 1] = steps[choice - 1], steps[choice]
                status = "OK: Moved up"
            elif action == 2 and choice < len(steps) - 1:
                steps[choice], steps[choice + 1] = steps[choice + 1], steps[choice]
                status = "OK: Moved down"
            elif action == 3:
                steps.pop(choice)
                status = "OK: Step removed"

def _scan_yaml_files(directory: str) -> List[str]:
    if not os.path.isdir(directory):
        return []

    results: List[str] = []
    try:
        for entry in os.listdir(directory):
            if entry.startswith('.'):
                continue
            if not entry.endswith(('.yaml', '.yml')):
                continue
            path = os.path.join(directory, entry)
            if os.path.isfile(path):
                results.append(path)
    except PermissionError:
        return []

    return results


def find_yamls() -> List[str]:
    cwd = os.getcwd()
    roots = list(dict.fromkeys([_legacy_config_dir(), _user_config_dir(), cwd]))

    found: List[str] = []
    for root in roots:
        candidates = list(_command_file_candidates(root))

        if root == cwd:
            for d in ('.commands-wrapper', 'commands-wrapper'):
                candidates.extend(_scan_yaml_files(os.path.join(root, d)))
        else:
            candidates.extend(_scan_yaml_files(root))

        found.extend(path for path in candidates if os.path.isfile(path))

    ordered: List[str] = []
    seen = set()
    for path in found:
        if path in seen:
            continue
        seen.add(path)
        ordered.append(path)

    return ordered


def _is_steps_key(key: Any) -> bool:
    return str(key).startswith('steps')


def _get_steps_key(cfg: Dict[str, Any]) -> Optional[str]:
    return next((k for k in cfg if _is_steps_key(k)), None)


def _parse_timeout(steps_key: str) -> Optional[int]:
    parts = str(steps_key).split(maxsplit=1)
    if len(parts) == 1:
        return None
    try:
        timeout = int(parts[1])
    except ValueError as exc:
        raise ValueError(f"invalid timeout in '{steps_key}'") from exc
    if timeout <= 0:
        raise ValueError(f"timeout must be positive in '{steps_key}'")
    return timeout


def _error(message: str) -> None:
    sys.stderr.write(f"{ANSI_ERROR}Error:{ANSI_RESET} {message}\n")


def _ok(message: str) -> None:
    print(f"{ANSI_SUCCESS}{message}{ANSI_RESET}")


def _warn(message: str) -> None:
    sys.stderr.write(f"{ANSI_WARN}Warning:{ANSI_RESET} {message}\n")


def _report_sync_messages(messages: List[str], emit: bool = True) -> bool:
    has_errors = False
    for message in messages:
        if message.startswith("WARN: "):
            if emit:
                _warn(message[6:])
        else:
            if emit:
                _error(message)
            has_errors = True
    return has_errors


def load_cmds(files: List[str], warnings: Optional[List[str]] = None) -> Dict[str, Dict[str, Any]]:
    cmds = {}
    for f in files:
        try:
            with open(f, encoding='utf-8') as stream:
                data = yaml.safe_load(stream)
        except OSError as exc:
            if warnings is not None:
                warnings.append(f"failed to read command file '{f}': {exc}")
            continue
        except yaml.YAMLError as exc:
            if warnings is not None:
                warnings.append(f"failed to parse command file '{f}': {exc}")
            continue

        if not isinstance(data, dict):
            continue

        for k, v in data.items():
            if not isinstance(v, dict):
                continue
            steps_key = _get_steps_key(v)
            if not steps_key:
                continue
            if not isinstance(v.get(steps_key), list):
                continue
            v['_source'] = f
            cmds[k] = v
    return cmds


def _is_own_wrapper_path(path: str, target_dir: str) -> bool:
    try:
        real_path = os.path.realpath(path)
    except OSError:
        return False

    if os.path.dirname(real_path) != os.path.realpath(target_dir):
        return False

    if not os.path.isfile(real_path):
        return False

    try:
        with open(real_path, 'r', encoding='utf-8', errors='ignore') as fd:
            header = fd.read(160)
    except OSError:
        return False

    return WRAPPER_MARKER in header


def _wrapper_name_from_command_name(command_name: str) -> Optional[str]:
    normalized = str(command_name).strip()
    if not normalized:
        return None

    wrapper_name = "-".join(normalized.split()).casefold()
    if not wrapper_name:
        return None

    if not all(c.isalnum() or c in '-_' for c in wrapper_name):
        return None

    if wrapper_name in (SHORT_ALIAS.casefold(), LEGACY_ALIAS.casefold()):
        return None

    return wrapper_name


def _wrapper_alias_from_command_name(command_name: str) -> Optional[str]:
    normalized = str(command_name).strip()
    if not normalized:
        return None

    wrapper_alias = "-".join(normalized.split())
    if not wrapper_alias:
        return None

    canonical = _wrapper_name_from_command_name(command_name)
    if not canonical:
        return None

    if wrapper_alias == canonical:
        return None

    if not all(c.isalnum() or c in '-_' for c in wrapper_alias):
        return None

    if wrapper_alias.casefold() in (SHORT_ALIAS.casefold(), LEGACY_ALIAS.casefold()):
        return None

    return wrapper_alias


def _namespace_prefix_from_command_name(command_name: str) -> Optional[str]:
    normalized = str(command_name).strip()
    if not normalized:
        return None

    parts = normalized.split()
    if len(parts) < 2:
        return None

    return parts[0]


def _command_lookup_key(name: Any) -> str:
    return str(name).strip().casefold()


def _build_command_lookup_index(db: Dict[str, Any]) -> Tuple[Dict[str, str], List[str]]:
    index: Dict[str, str] = {}
    errors: List[str] = []

    for raw_name in db.keys():
        raw_command_name = str(raw_name)
        command_name = raw_command_name.strip()
        if not command_name:
            continue

        lookup_key = _command_lookup_key(command_name)
        previous = index.get(lookup_key)
        if previous and previous != raw_command_name:
            errors.append(
                f"case-insensitive command name collision: {previous!r} vs {raw_command_name!r}"
            )
            continue

        index[lookup_key] = raw_command_name

    return index, errors


def _resolve_command_name(
    requested: str,
    db: Dict[str, Any],
    lookup_index: Dict[str, str],
) -> Optional[str]:
    if requested in db:
        return requested

    return lookup_index.get(_command_lookup_key(requested))


def _find_case_insensitive_conflict(
    name: str,
    candidates: List[str],
    *,
    ignore_name: Optional[str] = None,
) -> Optional[str]:
    target_key = _command_lookup_key(name)
    for candidate in candidates:
        if ignore_name is not None and candidate == ignore_name:
            continue
        if _command_lookup_key(candidate) == target_key:
            return candidate
    return None


def _format_conflict_warning(wrapper_name: str, command_name: str) -> str:
    return (
        f"WARN: skipped naked wrapper '{wrapper_name}' for command '{command_name}' "
        "because that name is already used by another executable on PATH. "
        f"Use '{SHORT_ALIAS} {command_name}' or '{PRIMARY_WRAPPER} {command_name}' instead."
    )


def _build_wrapper_map(db: Dict[str, Any]) -> Tuple[Dict[str, str], List[str]]:
    wrappers: Dict[str, str] = {}
    errors: List[str] = []

    for key in db.keys():
        command_name = str(key).strip()
        wrapper_name = _wrapper_name_from_command_name(command_name)
        if not wrapper_name:
            continue

        wrapper_targets: List[Tuple[str, str]] = [(wrapper_name, command_name)]

        wrapper_alias = _wrapper_alias_from_command_name(command_name)
        if wrapper_alias:
            wrapper_targets.append((wrapper_alias, command_name))

        namespace_prefix = _namespace_prefix_from_command_name(command_name)
        if namespace_prefix:
            namespace_wrapper = _wrapper_name_from_command_name(namespace_prefix)
            if namespace_wrapper:
                wrapper_targets.append((namespace_wrapper, namespace_prefix))

            namespace_alias = _wrapper_alias_from_command_name(namespace_prefix)
            if namespace_alias:
                wrapper_targets.append((namespace_alias, namespace_prefix))

        seen_targets: Dict[str, str] = {}
        for candidate, target_command in wrapper_targets:
            if candidate in seen_targets:
                continue
            seen_targets[candidate] = target_command

        for candidate, target_command in seen_targets.items():
            previous = wrappers.get(candidate)
            if previous and previous != target_command:
                errors.append(
                    f"wrapper name collision for '{candidate}': '{previous}' vs '{target_command}'"
                )
                continue

            wrappers[candidate] = target_command

    return wrappers, errors


def _build_wrapper_map_with_conflicts(
    db: Dict[str, Any],
    target_dir: str,
    report_conflicts: bool = True,
) -> Tuple[Dict[str, str], List[str], Dict[str, str]]:
    wrappers, errors = _build_wrapper_map(db)
    filtered: Dict[str, str] = {}
    blocked: Dict[str, str] = {}

    search_path = os.environ.get('PATH')

    for wrapper_name, command_name in wrappers.items():
        resolved = shutil.which(wrapper_name, path=search_path)

        if resolved and not _is_own_wrapper_path(resolved, target_dir):
            blocked[wrapper_name] = command_name
            if report_conflicts:
                errors.append(_format_conflict_warning(wrapper_name, command_name))
            continue

        filtered[wrapper_name] = command_name

    return filtered, errors, blocked


def _wrapper_conflict_warnings_for_command(
    db: Dict[str, Any],
    command_name: str,
    target_dir: Optional[str] = None,
) -> List[str]:
    destination = target_dir or _script_bin_dir(os.name)
    _, errors, blocked = _build_wrapper_map_with_conflicts(
        db,
        destination,
        report_conflicts=False,
    )

    target_keys = {_command_lookup_key(command_name)}
    namespace_prefix = _namespace_prefix_from_command_name(command_name)
    if namespace_prefix:
        target_keys.add(_command_lookup_key(namespace_prefix))

    warnings: List[str] = []
    for wrapper_name, blocked_command in blocked.items():
        if _command_lookup_key(blocked_command) not in target_keys:
            continue
        warnings.append(_format_conflict_warning(wrapper_name, blocked_command))

    return [*errors, *warnings]



def sync_binaries(
    db: Dict[str, Any],
    uninstall: bool = False,
    bin_dir: Optional[str] = None,
    platform_name: Optional[str] = None,
    report_conflicts: bool = True,
)-> List[str]:
    import stat

    errors: List[str] = []
    plat = platform_name or os.name
    target_dir = bin_dir or _script_bin_dir(plat)
    try:
        os.makedirs(target_dir, exist_ok=True)
    except OSError as exc:
        reason = exc.strerror or str(exc)
        return [f"failed to create wrapper directory '{target_dir}': {reason}"]

    custom_wrappers: Dict[str, str] = {}
    if not uninstall:
        custom_wrappers, wrapper_errors, _ = _build_wrapper_map_with_conflicts(
            db,
            target_dir,
            report_conflicts=report_conflicts,
        )
        errors.extend(wrapper_errors)

    wrapper_targets: Dict[str, Optional[str]] = {}
    if not uninstall:
        wrapper_targets = {
            SHORT_ALIAS: None,
            LEGACY_ALIAS: None,
        }
        wrapper_targets.update(custom_wrappers)

    expected_commands = set(wrapper_targets.keys())

    if plat == 'nt':
        expected_files = {
            f"{name}{suffix}"
            for name in expected_commands
            for suffix in ('.cmd', '.ps1')
        }
    else:
        expected_files = set(expected_commands)

    try:
        existing_files = os.listdir(target_dir)
    except OSError as exc:
        reason = exc.strerror or str(exc)
        errors.append(f"failed to list wrapper directory '{target_dir}': {reason}")
        existing_files = []

    for filename in existing_files:
        path = os.path.join(target_dir, filename)
        if not os.path.isfile(path):
            continue
        try:
            with open(path, 'r', encoding='utf-8', errors='ignore') as fd:
                header = fd.read(160)
            if WRAPPER_MARKER in header and filename not in expected_files:
                os.remove(path)
        except OSError as exc:
            reason = exc.strerror or str(exc)
            errors.append(f"failed to reconcile wrapper '{path}': {reason}")

    if uninstall:
        return errors

    wrapper_target = os.path.realpath(__file__)
    if not os.path.isfile(wrapper_target):
        wrapper_target = os.path.realpath(sys.argv[0]) if os.path.isfile(sys.argv[0]) else PRIMARY_WRAPPER
    python_q = _cmd_quote(sys.executable)
    target_q = _cmd_quote(wrapper_target)
    wrapper_target_q = shlex.quote(wrapper_target)

    for entry, command_name in wrapper_targets.items():
        if command_name is None:
            unix_exec_line = f'exec {wrapper_target_q} "$@"\n'
            cmd_forward = '%*'
            ps1_forward = '@args'
        else:
            command_name_q = shlex.quote(command_name)
            unix_exec_line = f'exec {wrapper_target_q} {command_name_q} "$@"\n'
            cmd_forward = f'{_cmd_quote(command_name)} %*'
            ps1_forward = f'{_cmd_quote(command_name)} @args'

        if plat == 'nt':
            cmd_path = os.path.join(target_dir, f"{entry}.cmd")
            ps1_path = os.path.join(target_dir, f"{entry}.ps1")

            cmd_content = (
                '@echo off\n'
                f'REM {WRAPPER_MARKER}\n'
                f'{python_q} {target_q} {cmd_forward}\n'
            )
            ps1_content = (
                f'# {WRAPPER_MARKER}\n'
                f'& {_cmd_quote(sys.executable)} {_cmd_quote(wrapper_target)} {ps1_forward}\n'
            )

            for wrapper_path, content in ((cmd_path, cmd_content), (ps1_path, ps1_content)):
                try:
                    with open(wrapper_path, 'w', encoding='utf-8', newline='\n') as fd:
                        fd.write(content)
                except OSError as exc:
                    reason = exc.strerror or str(exc)
                    errors.append(f"failed to write wrapper '{wrapper_path}': {reason}")
        else:
            script_path = os.path.join(target_dir, entry)
            content = (
                '#!/usr/bin/env sh\n'
                f'# {WRAPPER_MARKER}\n'
                f'{unix_exec_line}'
            )
            try:
                with open(script_path, 'w', encoding='utf-8', newline='\n') as fd:
                    fd.write(content)
                st = os.stat(script_path)
                os.chmod(script_path, st.st_mode | stat.S_IEXEC)
            except OSError as exc:
                reason = exc.strerror or str(exc)
                errors.append(f"failed to write wrapper '{script_path}': {reason}")

    return errors


def _restore_command_file_snapshot(file_path: str, snapshot: Optional[str]) -> Optional[str]:
    try:
        if snapshot is None:
            if os.path.exists(file_path):
                os.remove(file_path)
        else:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(snapshot)
    except OSError as exc:
        return f"failed to restore source file: {exc}"

    return None

def save_cmd(name: str, cfg: Dict[str, Any], file_path: str) -> List[str]:
    data: Dict[str, Any] = {}
    original_content: Optional[str] = None
    if os.path.exists(file_path):
        try:
            with open(file_path, encoding='utf-8') as f:
                original_content = f.read()
                loaded = yaml.safe_load(original_content)
                if isinstance(loaded, dict):
                    data = loaded
        except OSError as exc:
            return [f"failed to read command file '{file_path}': {exc}"]
        except yaml.YAMLError as exc:
            return [f"failed to parse command file '{file_path}': {exc}"]

    all_commands = load_cmds(find_yamls())
    lookup_index, lookup_errors = _build_command_lookup_index(all_commands)
    if lookup_errors:
        return lookup_errors

    existing_name = lookup_index.get(_command_lookup_key(name))
    if existing_name and existing_name != name:
        return [
            f"command name '{name}' conflicts with existing command '{existing_name}' under case-insensitive lookup"
        ]

    parent = os.path.dirname(file_path)
    if parent:
        os.makedirs(parent, exist_ok=True)

    clean_cfg = {k: v for k, v in cfg.items() if k != '_source'}
    data[name] = clean_cfg
    with open(file_path, 'w', encoding='utf-8') as f:
        yaml.safe_dump(data, f, sort_keys=False)

    sync_messages = sync_binaries(load_cmds(find_yamls()))
    if not _report_sync_messages(sync_messages, emit=False):
        return sync_messages

    rollback_error = _restore_command_file_snapshot(file_path, original_content)
    rollback_sync_messages = sync_binaries(load_cmds(find_yamls()))

    messages = list(sync_messages)
    if rollback_error:
        messages.append(rollback_error)
        return messages

    if _report_sync_messages(rollback_sync_messages, emit=False):
        messages.append("failed to restore wrappers after source rollback")
        messages.extend(rollback_sync_messages)
    else:
        messages.append("wrapper sync failed; source file was restored")

    return messages


def remove_from_file(name: str, file_path: str) -> Tuple[bool, str, List[str]]:
    if not os.path.exists(file_path):
        return False, f"source file not found: {file_path}", []
    try:
        with open(file_path, encoding='utf-8') as f:
            original_content = f.read()
            loaded = yaml.safe_load(original_content)
            data = loaded if isinstance(loaded, dict) else {}

        if name not in data:
            return False, f"'{name}' not found in source file", []

        del data[name]
        with open(file_path, 'w', encoding='utf-8') as f:
            yaml.safe_dump(data, f, sort_keys=False)

        sync_errors = sync_binaries(load_cmds(find_yamls()))
        if _report_sync_messages(sync_errors, emit=False):
            rollback_error = _restore_command_file_snapshot(file_path, original_content)
            rollback_sync_errors = sync_binaries(load_cmds(find_yamls()))

            if rollback_error:
                return False, f"wrapper sync failed and rollback failed: {rollback_error}", sync_errors
            if _report_sync_messages(rollback_sync_errors, emit=False):
                return (
                    False,
                    "wrapper sync failed and source file was restored, but wrapper rollback failed",
                    [*sync_errors, *rollback_sync_errors],
                )

            return False, "wrapper sync failed; source file was restored", sync_errors

        return True, "", sync_errors
    except (OSError, yaml.YAMLError) as exc:
        return False, f"failed to update source file: {exc}", []


def rename_in_file(old_name: str, new_name: str, file_path: str) -> Tuple[bool, str, List[str]]:
    if not os.path.exists(file_path):
        return False, f"source file not found: {file_path}", []

    try:
        with open(file_path, encoding='utf-8') as f:
            original_content = f.read()
            loaded = yaml.safe_load(original_content)
            data = loaded if isinstance(loaded, dict) else {}
    except (OSError, yaml.YAMLError) as exc:
        return False, f"failed to read source file: {exc}", []

    if old_name not in data:
        return False, f"'{old_name}' not found in source file", []

    all_commands = load_cmds(find_yamls())
    lookup_index, lookup_errors = _build_command_lookup_index(all_commands)
    if lookup_errors:
        return False, lookup_errors[0], []

    existing_name = lookup_index.get(_command_lookup_key(new_name))
    if existing_name and existing_name != old_name:
        return (
            False,
            f"'{new_name}' conflicts with existing command '{existing_name}' under case-insensitive lookup",
            [],
        )

    if new_name != old_name and new_name in data:
        return False, f"'{new_name}' already exists in source file", []

    if new_name != old_name:
        data[new_name] = data.pop(old_name)

    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            yaml.safe_dump(data, f, sort_keys=False)
    except OSError as exc:
        return False, f"failed to write source file: {exc}", []

    sync_messages = sync_binaries(load_cmds(find_yamls()))
    if _report_sync_messages(sync_messages, emit=False):
        rollback_error = _restore_command_file_snapshot(file_path, original_content)
        rollback_sync_messages = sync_binaries(load_cmds(find_yamls()))

        if rollback_error:
            return False, f"wrapper sync failed and rollback failed: {rollback_error}", sync_messages
        if _report_sync_messages(rollback_sync_messages, emit=False):
            return (
                False,
                "wrapper sync failed and source file was restored, but wrapper rollback failed",
                [*sync_messages, *rollback_sync_messages],
            )

        return False, "wrapper sync failed; source file was restored", sync_messages

    return True, "", sync_messages


def _is_valid_name(name: str) -> bool:
    """Command names must be non-empty and contain only safe characters."""
    return bool(name) and all(c.isalnum() or c in '-_ ' for c in name) and not name.isspace()


def _wizard_add(win) -> bool:
    fields = [
        Field("name", "Command"),
        Field("desc", "Description"),
        Field("timeout", "Timeout in seconds (optional)"),
    ]

    while True:
        res = form_input(win, "Add command", fields)
        if not res:
            return False

        name = res['name'].strip()
        if not _is_valid_name(name):
            y = _draw_header(win, "Add command")
            _addstr(win, y, 4, "Invalid command name. Use letters, numbers, spaces, '-' or '_'.", ERR())
            _addstr(win, y + 2, 4, "Press any key to continue.", DIM())
            win.refresh()
            win.getch()
            continue

        existing = load_cmds(find_yamls())
        conflict_name = _find_case_insensitive_conflict(name, list(existing.keys()))
        if conflict_name:
            y = _draw_header(win, "Add command")
            if conflict_name == name:
                _addstr(win, y, 4, f"Command '{name}' already exists.", ERR())
            else:
                _addstr(
                    win,
                    y,
                    4,
                    f"Command '{name}' conflicts with '{conflict_name}' under case-insensitive lookup.",
                    ERR(),
                )
            _addstr(win, y + 2, 4, "Use edit mode from the command list to update it.", DIM())
            _addstr(win, y + 4, 4, "Press any key to continue.", DIM())
            win.refresh()
            win.getch()
            continue

        steps = steps_editor(win, [])
        if steps is None:
            return False

        timeout = res['timeout'].strip()
        steps_key = f"steps {timeout}" if timeout else "steps"
        try:
            _parse_timeout(steps_key)
        except ValueError:
            y = _draw_header(win, "Add command")
            _addstr(win, y, 4, "Invalid timeout. Use a positive integer or leave empty.", ERR())
            _addstr(win, y + 2, 4, "Press any key to continue.", DIM())
            win.refresh()
            win.getch()
            continue

        target = _preferred_command_file_for_write()
        sync_messages = save_cmd(name, {"description": res['desc'].strip(), steps_key: steps}, target)
        if _report_sync_messages(sync_messages, emit=False):
            y = _draw_header(win, "Add command")
            _addstr(win, y, 4, "Failed to add command due validation or sync errors.", ERR())
            _addstr(win, y + 2, 4, f"Target file: {target}", DIM())
            _addstr(win, y + 4, 4, "Press any key to continue.", DIM())
            win.refresh()
            win.getch()
            continue
        return True


def _menu_line_for_command(name: str, cfg: Dict[str, Any]) -> str:
    name_col = name if len(name) <= 24 else f"{name[:21]}..."
    desc = str(cfg.get('description', '')).strip()
    if not desc:
        return f"{name_col:<24} |"
    short_desc = desc if len(desc) <= 56 else f"{desc[:53]}..."
    return f"{name_col:<24} | {short_desc}"


def _wizard_edit_command(win, name: str) -> str:
    status = ""
    current_name = name

    while True:
        db = load_cmds(find_yamls())
        cfg = db.get(current_name)
        if not cfg:
            return f"OK: Removed '{current_name}'."

        action = menu(win, f"Edit - {current_name}", [
            "Rename command",
            "Edit metadata",
            "Edit steps",
            "Delete",
            "Back",
        ], status)
        status = ""

        if action is None or action == 4:
            return ""

        if action == 0:
            res = form_input(win, f"Rename - {current_name}", [Field("name", "Command name", value=current_name)])
            if not res:
                continue

            new_name = res["name"].strip()
            if not _is_valid_name(new_name):
                status = "ERR: Invalid command name"
                continue

            conflict_name = _find_case_insensitive_conflict(
                new_name,
                list(db.keys()),
                ignore_name=current_name,
            )
            if conflict_name:
                if conflict_name == new_name:
                    status = f"ERR: Command '{new_name}' already exists"
                else:
                    status = (
                        f"ERR: Command '{new_name}' conflicts with '{conflict_name}' "
                        "under case-insensitive lookup"
                    )
                continue

            renamed, err_message, sync_messages = rename_in_file(current_name, new_name, cfg['_source'])
            if not renamed:
                status = f"ERR: {err_message}"
                continue

            current_name = new_name
            status = "OK: Command renamed."
            if _report_sync_messages(sync_messages, emit=False):
                status = "WARN: Command renamed with sync issues."

        elif action == 1:
            old_steps_key = next((k for k in cfg if str(k).startswith('steps')), 'steps')
            old_timeout = str(old_steps_key).replace('steps', '').strip()

            fields = [
                Field("desc", "Description", value=cfg.get('description', '')),
                Field("timeout", "Timeout (seconds)", value=old_timeout),
            ]
            res = form_input(win, f"Edit metadata - {current_name}", fields)
            if not res:
                continue

            cfg['description'] = res['desc'].strip()
            timeout = res['timeout'].strip()
            steps_key = f"steps {timeout}" if timeout else "steps"
            try:
                _parse_timeout(steps_key)
            except ValueError:
                status = "ERR: Timeout must be a positive integer"
                continue

            if steps_key != old_steps_key:
                cfg[steps_key] = cfg.pop(old_steps_key)

            sync_messages = save_cmd(current_name, cfg, cfg['_source'])
            status = "OK: Metadata updated."
            if _report_sync_messages(sync_messages, emit=False):
                status = "WARN: Metadata saved with sync issues."

        elif action == 2:
            old_steps_key = next((k for k in cfg if str(k).startswith('steps')), 'steps')
            existing_steps = cfg.get(old_steps_key, [])
            steps = steps_editor(win, existing_steps)
            if steps is not None:
                cfg[old_steps_key] = steps
                sync_messages = save_cmd(current_name, cfg, cfg['_source'])
                status = "OK: Steps updated."
                if _report_sync_messages(sync_messages, emit=False):
                    status = "WARN: Steps saved with sync issues."

        elif action == 3:
            confirm = menu(win, f"Delete '{current_name}'?", ["Cancel", "Delete"])
            if confirm == 1:
                removed, err_message, sync_messages = remove_from_file(current_name, cfg['_source'])
                if not removed:
                    status = f"ERR: {err_message}"
                    continue

                if _report_sync_messages(sync_messages, emit=False):
                    return f"WARN: Removed '{current_name}' with sync issues."
                return f"OK: Removed '{current_name}'."


def _wizard_main(win):
    _init_colors()
    try:
        curses.curs_set(0)
    except curses.error:
        pass

    win.keypad(True)
    win.timeout(-1)

    status = ""
    startup_sync_done = False
    while True:
        db = load_cmds(find_yamls())
        if not startup_sync_done:
            auto_sync_messages = sync_binaries(db)
            auto_sync_has_errors = _report_sync_messages(auto_sync_messages, emit=False)
            auto_sync_has_warnings = any(msg.startswith("WARN: ") for msg in auto_sync_messages)

            if not status:
                if auto_sync_has_errors:
                    status = "WARN: Automatic wrapper sync had errors."
                elif auto_sync_has_warnings:
                    status = "WARN: Some naked wrappers are disabled due to command conflicts."

            startup_sync_done = True

        command_names = sorted(db.keys())
        if not command_names and not status:
            status = "INFO: No commands yet. Add one to get started."

        options = ["+ Add new command"]
        if command_names:
            options.extend(_menu_line_for_command(name, db[name]) for name in command_names)
        options.extend([
            "Refresh list",
            "Exit",
        ])

        command_count = len(command_names)
        first_command_idx = 1
        refresh_idx = first_command_idx + command_count
        exit_idx = refresh_idx + 1

        choice = menu(win, "Command wrappers (Enter edits)", options, status)
        status = ""

        if choice is None or choice == exit_idx:
            break

        if choice == 0:
            if _wizard_add(win):
                status = "OK: Command saved."
            else:
                status = "WARN: Add command canceled."
            continue

        if choice == refresh_idx:
            status = "OK: Refreshed."
            startup_sync_done = False
            continue

        if command_count == 0:
            status = "INFO: No commands yet. Add one to get started."
            continue

        selected_idx = choice - first_command_idx
        if selected_idx < 0 or selected_idx >= command_count:
            continue

        selected_name = command_names[selected_idx]
        status = _wizard_edit_command(win, selected_name)



def _run_basic_wizard() -> None:
    print(f"{ANSI_BOLD}{HEADER_TITLE}{ANSI_RESET}")
    print("Terminal UI is unavailable on this platform or shell.")
    print("Use non-interactive commands instead:")
    print(f"  {PRIMARY_WRAPPER} add --yaml <<EOF")
    print("  ...")
    print("  EOF")
    print(f"  {PRIMARY_WRAPPER} list")
    print(f"  {PRIMARY_WRAPPER} remove <name>")


def _strip_add_yaml_flag(argv: List[str]) -> Tuple[List[str], bool]:
    if len(argv) < 2 or argv[1].casefold() != 'add':
        return list(argv), False

    filtered = [argv[0]]
    has_yaml_flag = False
    for part in argv[1:]:
        if isinstance(part, str) and part.casefold() == '--yaml':
            has_yaml_flag = True
            continue
        filtered.append(part)
    return filtered, has_yaml_flag


def run_wizard():
    if not _has_tui_support():
        _run_basic_wizard()
        return

    try:
        curses.wrapper(_wizard_main)
    except KeyboardInterrupt:
        pass


def _run_pip(args: List[str], cwd: Optional[str] = None, suppress_output: bool = False) -> int:
    base = [sys.executable, '-m', 'pip', *args]
    kwargs: Dict[str, Any] = {'cwd': cwd}
    if suppress_output:
        kwargs['stdout'] = subprocess.DEVNULL
        kwargs['stderr'] = subprocess.DEVNULL

    with_break = subprocess.run([*base, '--break-system-packages'], **kwargs)
    if with_break.returncode == 0:
        return 0

    fallback = subprocess.run(base, **kwargs)
    return fallback.returncode


def _extract_cd_target(command: Any) -> Optional[str]:
    if not isinstance(command, str):
        return None

    try:
        parts = shlex.split(command, posix=(os.name != 'nt'))
    except ValueError:
        return None

    if not parts or parts[0] != 'cd':
        return None

    if len(parts) == 1:
        return '~'

    if len(parts) == 2:
        return parts[1]

    return None


def _resolve_cd_target(target: str) -> str:
    if target == '-':
        previous = os.environ.get('OLDPWD')
        if not previous:
            raise ValueError("OLDPWD is not set for 'cd -'.")
        target = previous

    expanded = os.path.expandvars(os.path.expanduser(target))
    if not os.path.isabs(expanded):
        expanded = os.path.abspath(os.path.join(os.getcwd(), expanded))
    return expanded


def _change_directory(target: str) -> None:
    destination = _resolve_cd_target(target)
    if not os.path.isdir(destination):
        raise ValueError(f"directory does not exist: {destination}")

    previous = os.getcwd()
    try:
        os.chdir(destination)
    except OSError as exc:
        reason = exc.strerror or str(exc)
        raise ValueError(f"unable to cd into '{target}': {reason}") from exc

    os.environ['OLDPWD'] = previous
    os.environ['PWD'] = os.getcwd()


def _is_single_cd_step(steps: List[Dict[str, Any]]) -> bool:
    if len(steps) != 1:
        return False
    step = steps[0]
    if not isinstance(step, dict):
        return False
    return _extract_cd_target(step.get('command')) is not None


def _open_interactive_shell() -> None:
    shell = _shell_name()
    args = [shell]
    if os.name != 'nt':
        args.append('-i')
    try:
        subprocess.run(args, cwd=os.getcwd(), check=False)
    except OSError as exc:
        reason = exc.strerror or str(exc)
        raise ValueError(f"unable to open interactive shell: {reason}") from exc


class StepTimeoutError(RuntimeError):
    """Raised when a command step exceeds its timeout."""


class CommandStepFailedError(RuntimeError):
    """Raised when a command step exits with a non-zero status."""

    def __init__(self, command: str, exit_code: int):
        self.command = command
        self.exit_code = exit_code
        super().__init__(f"command failed with exit code {exit_code}: {command}")


class ProcessAdapter:
    def isalive(self) -> bool:
        raise NotImplementedError

    def interact(self) -> None:
        raise NotImplementedError

    def close(self) -> None:
        raise NotImplementedError

    def sendline(self, text: str = "") -> None:
        raise NotImplementedError

    def send(self, text: str) -> None:
        raise NotImplementedError

    def returncode(self) -> Optional[int]:
        raise NotImplementedError

    def command_text(self) -> str:
        raise NotImplementedError


class PExpectProcessAdapter(ProcessAdapter):
    def __init__(self, command: str, timeout: Optional[int]):
        self._command = command
        self._proc = pexpect.spawn(
            _shell_name(),
            ['-c', command],
            encoding='utf-8',
            timeout=timeout,
        )
        self._proc.logfile_read = sys.stdout

    def isalive(self) -> bool:
        return self._proc.isalive()

    def interact(self) -> None:
        try:
            self._proc.interact()
            return
        except pexpect.TIMEOUT as exc:
            raise StepTimeoutError from exc
        except NON_INTERACTIVE_INTERACT_EXCEPTIONS:
            # Non-interactive shells (CI, pipes) cannot attach a TTY.
            pass

        try:
            self._proc.expect(pexpect.EOF, timeout=self._proc.timeout)
        except pexpect.TIMEOUT as exc:
            raise StepTimeoutError from exc

    def close(self) -> None:
        self._proc.close()

    def sendline(self, text: str = "") -> None:
        self._proc.sendline(text)

    def send(self, text: str) -> None:
        self._proc.send(text)

    def returncode(self) -> Optional[int]:
        if self._proc.exitstatus is not None:
            return self._proc.exitstatus
        if self._proc.signalstatus is not None:
            return 128 + self._proc.signalstatus
        return None

    def command_text(self) -> str:
        return self._command


class SubprocessProcessAdapter(ProcessAdapter):
    def __init__(self, command: str, timeout: Optional[int]):
        self._command = command
        self._timeout = timeout
        kwargs: Dict[str, Any] = {
            'stdin': subprocess.PIPE,
            'stdout': subprocess.PIPE,
            'stderr': subprocess.STDOUT,
            'text': True,
            'encoding': 'utf-8',
            'errors': 'replace',
            'bufsize': 1,
            'shell': True,
        }
        if os.name != 'nt':
            kwargs['executable'] = _shell_name()
        self._proc = subprocess.Popen(command, **kwargs)
        self._reader_done = threading.Event()
        self._reader = threading.Thread(target=self._pump_stdout, daemon=True)
        self._reader.start()

    def _pump_stdout(self) -> None:
        try:
            if not self._proc.stdout:
                return
            for line in self._proc.stdout:
                sys.stdout.write(line)
                sys.stdout.flush()
        finally:
            self._reader_done.set()

    def isalive(self) -> bool:
        return self._proc.poll() is None

    def interact(self) -> None:
        try:
            self._proc.wait(timeout=self._timeout)
        except subprocess.TimeoutExpired as exc:
            raise StepTimeoutError from exc
        finally:
            self._reader_done.wait(timeout=0.5)

    def close(self) -> None:
        if self.isalive():
            self._proc.terminate()
            try:
                self._proc.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self._proc.kill()
                self._proc.wait(timeout=2)
        self._reader_done.wait(timeout=0.5)

        for stream in (self._proc.stdin, self._proc.stdout, self._proc.stderr):
            try:
                if stream:
                    stream.close()
            except (OSError, ValueError):
                pass

    def sendline(self, text: str = "") -> None:
        self.send(text + "\n")

    def send(self, text: str) -> None:
        if not self._proc.stdin:
            raise ValueError('cannot send input to command without stdin')
        if not self.isalive():
            raise ValueError('cannot send input: process already exited')
        self._proc.stdin.write(text)
        self._proc.stdin.flush()

    def returncode(self) -> Optional[int]:
        return self._proc.returncode

    def command_text(self) -> str:
        return self._command


def _safe_exit_code(code: int) -> int:
    if 0 < code < 256:
        return code
    return 1


def _finalize_process(proc: ProcessAdapter) -> None:
    try:
        proc.interact()
    finally:
        proc.close()

    code = proc.returncode()
    if code is None:
        raise ValueError(f"unable to determine exit status for command: {proc.command_text()}")
    if code != 0:
        raise CommandStepFailedError(proc.command_text(), code)


def _spawn_process(command: str, timeout: Optional[int]) -> ProcessAdapter:
    if PEXPECT_AVAILABLE and os.name != 'nt':
        return PExpectProcessAdapter(command, timeout)
    return SubprocessProcessAdapter(command, timeout)


def run_step(proc: Optional[ProcessAdapter], ctx: Dict[str, Any], timeout: Optional[int]):
    if 'command' in ctx:
        command_text = str(ctx['command'])
        cd_target = _extract_cd_target(command_text)

        if proc is not None:
            _finalize_process(proc)

        if cd_target is not None:
            _change_directory(cd_target)
            return None

        print(f"\n{ANSI_MUTED}$ {ANSI_RESET}{command_text}")
        return _spawn_process(command_text, timeout)

    if 'send' in ctx:
        if not proc:
            raise ValueError("'send' step requires a running command step")
        proc.sendline(str(ctx['send']))
        return proc

    if 'press_key' in ctx:
        if not proc:
            raise ValueError("'press_key' step requires a running command step")
        raw_key = str(ctx['press_key'])
        key_name = raw_key.strip().casefold()
        if key_name in ('enter', 'return'):
            proc.sendline()
        elif key_name == 'tab':
            proc.send('\t')
        elif key_name in ('esc', 'escape'):
            proc.send('\x1b')
        else:
            proc.send(raw_key)
        return proc

    if 'wait' in ctx:
        try:
            duration = float(ctx['wait'])
        except (TypeError, ValueError) as exc:
            raise ValueError(f"invalid wait duration: {ctx['wait']}") from exc
        if duration < 0:
            raise ValueError(f"wait duration must be non-negative: {ctx['wait']}")
        time.sleep(duration)
        return proc

    raise ValueError(f"invalid step object: {ctx}")

def exec_cmd(name: str, cfg: Dict[str, Any]) -> None:
    key = _get_steps_key(cfg)
    if not key:
        _error(f"'{name}' has no steps configured.")
        sys.exit(1)

    try:
        t = _parse_timeout(key)
    except ValueError as exc:
        _error(str(exc))
        sys.exit(1)

    steps = cfg.get(key)
    if not isinstance(steps, list):
        _error(f"'{name}' has an invalid steps definition.")
        sys.exit(1)

    if not steps:
        _error(f"'{name}' has no steps to execute.")
        sys.exit(1)

    single_cd_step = _is_single_cd_step(steps)

    proc: Optional[ProcessAdapter] = None
    try:
        for s in steps:
            if not isinstance(s, dict):
                raise ValueError(f"invalid step in '{name}': expected mapping")
            proc = run_step(proc, s, t)
    except ValueError as exc:
        _error(str(exc))
        sys.exit(1)
    except CommandStepFailedError as exc:
        _error(str(exc))
        sys.exit(_safe_exit_code(exc.exit_code))
    except StepTimeoutError:
        _error(f"command '{name}' timed out.")
        sys.exit(1)

    if proc is not None:
        try:
            _finalize_process(proc)
        except CommandStepFailedError as exc:
            _error(str(exc))
            sys.exit(_safe_exit_code(exc.exit_code))
        except StepTimeoutError:
            _error(f"command '{name}' timed out.")
            sys.exit(1)
    elif single_cd_step and sys.stdin.isatty() and sys.stdout.isatty():
        try:
            _open_interactive_shell()
        except ValueError as exc:
            _error(str(exc))
            sys.exit(1)


def print_list(db: Dict):
    print(f"{ANSI_BOLD}{HEADER_TITLE}{ANSI_RESET}")
    if not db:
        print(f"{ANSI_MUTED}No commands found.{ANSI_RESET}")
        return
    print(f"{ANSI_BOLD}{'NAME':<22} DESCRIPTION{ANSI_RESET}")
    print(f"{ANSI_MUTED}{'-' * 72}{ANSI_RESET}")
    for k, v in sorted(db.items()):
        print(f"{ANSI_PRIMARY}{k:<22}{ANSI_RESET} {v.get('description', '')}")
    print()


def cmd_add_yaml(yaml_str: str):
    try:
        data = yaml.safe_load(yaml_str)
    except yaml.YAMLError as exc:
        _error(f"YAML parse error: {exc}")
        sys.exit(1)

    if not isinstance(data, dict):
        _error("Input must be a YAML mapping.")
        sys.exit(1)

    target = _preferred_command_file_for_write()
    existing_commands = load_cmds(find_yamls())
    lookup_index, lookup_errors = _build_command_lookup_index(existing_commands)
    if lookup_errors:
        for message in lookup_errors:
            _error(message)
        sys.exit(1)

    had_errors = False
    added_count = 0

    for name, cfg in data.items():
        if not isinstance(cfg, dict):
            had_errors = True
            continue

        normalized_name = str(name).strip()
        if not _is_valid_name(normalized_name):
            _error(f"skipping '{name}': invalid command name")
            had_errors = True
            continue

        steps_key = _get_steps_key(cfg)
        if not steps_key:
            _error(f"skipping '{name}': no steps key found")
            had_errors = True
            continue

        if not isinstance(cfg.get(steps_key), list):
            _error(f"skipping '{name}': steps value must be a list")
            had_errors = True
            continue

        lookup_key = _command_lookup_key(normalized_name)
        existing_name = lookup_index.get(lookup_key)
        if existing_name and existing_name != normalized_name:
            _error(
                f"skipping '{name}': conflicts with existing command '{existing_name}' under case-insensitive lookup"
            )
            had_errors = True
            continue

        try:
            _parse_timeout(steps_key)
        except ValueError as exc:
            _error(f"skipping '{name}': {exc}")
            had_errors = True
            continue

        sync_messages = save_cmd(normalized_name, cfg, target)
        has_sync_errors = _report_sync_messages(sync_messages)
        if has_sync_errors:
            had_errors = True
            continue

        existing_commands[normalized_name] = cfg
        lookup_index[lookup_key] = normalized_name
        added_count += 1
        _ok(f"Added '{normalized_name}' to {target}")

    if added_count == 0:
        _error("No valid commands were added.")
        sys.exit(1)

    if had_errors:
        sys.exit(1)


def _pip_install():
    location = _find_package_source()
    if not location:
        _error("cannot locate package source. Run 'pip install . --break-system-packages' from the project root.")
        sys.exit(1)
    return_code = _run_pip(['install', location], cwd=location)
    sys.exit(return_code)


def _pip_uninstall():
    sync_errors = sync_binaries({}, uninstall=True)
    _report_sync_messages(sync_errors)

    if _run_pip(['show', PRIMARY_WRAPPER], suppress_output=True) != 0:
        _warn(f"{PRIMARY_WRAPPER} is not installed.")
        sys.exit(0)

    return_code = _run_pip(['uninstall', PRIMARY_WRAPPER, '-y'])
    if return_code == 0:
        _ok(f"Uninstalled {PRIMARY_WRAPPER}.")
    sys.exit(return_code)


def _find_package_source() -> Optional[str]:
    current = os.path.realpath(__file__)
    for _ in range(3):
        current = os.path.dirname(current)
        if os.path.isfile(os.path.join(current, 'pyproject.toml')):
            return current
    candidate = os.path.dirname(_SCRIPT_DIR)
    if os.path.isfile(os.path.join(candidate, 'pyproject.toml')):
        return candidate
    return None


def _sha256_file(path: str) -> str:
    digest = hashlib.sha256()
    with open(path, 'rb') as fd:
        for chunk in iter(lambda: fd.read(1024 * 1024), b''):
            digest.update(chunk)
    return digest.hexdigest()


def _prepare_update_source() -> Tuple[str, Optional[str]]:
    expected_sha256 = os.environ.get('COMMANDS_WRAPPER_UPDATE_SHA256', '').strip().lower()
    if not expected_sha256:
        return UPDATE_TARBALL_URL, None

    if len(expected_sha256) != 64 or any(c not in '0123456789abcdef' for c in expected_sha256):
        raise ValueError('invalid COMMANDS_WRAPPER_UPDATE_SHA256 value')

    fd, archive_path = tempfile.mkstemp(prefix='commands-wrapper-update-', suffix='.tar.gz')
    os.close(fd)

    try:
        with urllib.request.urlopen(UPDATE_TARBALL_URL) as response, open(archive_path, 'wb') as out:
            shutil.copyfileobj(response, out)
    except (OSError, urllib.error.URLError) as exc:
        try:
            os.remove(archive_path)
        except OSError:
            pass
        raise ValueError(f'failed to download update archive: {exc}') from exc

    actual_sha256 = _sha256_file(archive_path)
    if actual_sha256 != expected_sha256:
        try:
            os.remove(archive_path)
        except OSError:
            pass
        raise ValueError('update archive checksum mismatch')

    return archive_path, archive_path


def _find_source_cli_for_build_artifact(script_path: Optional[str] = None) -> Optional[str]:
    current = os.path.realpath(script_path or __file__)
    normalized = current.replace('\\', '/')
    if '/build/scripts-' not in normalized:
        return None

    repo_root = os.path.dirname(os.path.dirname(os.path.dirname(current)))
    source_cli = os.path.join(repo_root, '.commands-wrapper', PRIMARY_WRAPPER)
    if not os.path.isfile(source_cli):
        return None

    source_real = os.path.realpath(source_cli)
    if source_real == current:
        return None

    return source_real


def _reexec_if_stale_build_script() -> None:
    source_cli = _find_source_cli_for_build_artifact()
    if not source_cli:
        return

    _warn(
        "detected execution from a build artifact; re-running with project source script "
        f"'{source_cli}'."
    )
    os.execv(sys.executable, [sys.executable, source_cli, *sys.argv[1:]])


def _auto_update():
    print(f"{ANSI_MUTED}Updating from GitHub...{ANSI_RESET}")
    try:
        update_source, cleanup_path = _prepare_update_source()
    except ValueError as exc:
        _error(str(exc))
        sys.exit(1)

    return_code = 1
    try:
        update_args = ['install', '--upgrade', '--force-reinstall', update_source]
        return_code = _run_pip(update_args, suppress_output=True)
        if return_code != 0:
            _warn("Initial update attempt failed; retrying with diagnostics.")
            return_code = _run_pip(update_args)

        if return_code == 0:
            sync_errors = sync_binaries(load_cmds(find_yamls()))
            if _report_sync_messages(sync_errors):
                return_code = 1
            else:
                _ok("Update complete.")
        else:
            _error(f"update failed with exit code {return_code}")
    finally:
        if cleanup_path:
            try:
                os.remove(cleanup_path)
            except OSError:
                pass

    sys.exit(return_code)


class _Parser(argparse.ArgumentParser):
    def exit(self, status=0, message=None):
        if message:
            self._print_message(message, sys.stderr)
        sys.exit(status)


def main():
    _reexec_if_stale_build_script()

    if sys.argv[1:] == ["--install"]:
        _pip_install()

    if sys.argv[1:] == ["--uninstall"]:
        _pip_uninstall()

    p = _Parser(description="Wrap multi-step shell sequences into a single named command.")
    p.add_argument("action", nargs=argparse.REMAINDER)
    args = p.parse_args()

    action_parts = args.action

    if not action_parts:
        run_wizard()
        return

    action = action_parts[0]
    normalized_action = action.casefold()
    full_action = " ".join(action_parts)

    load_warnings: List[str] = []
    db = load_cmds(find_yamls(), warnings=load_warnings)
    for warning in load_warnings:
        _warn(warning)
    lookup_index, lookup_errors = _build_command_lookup_index(db)
    if lookup_errors:
        for message in lookup_errors:
            _error(message)
        sys.exit(1)

    resolved_full_action = _resolve_command_name(full_action, db, lookup_index)
    resolved_action = _resolve_command_name(action, db, lookup_index)

    if normalized_action not in ('sync', 'add', 'rm', 'remove', 'configure', 'config'):
        _report_sync_messages(sync_binaries(db, report_conflicts=False))

        command_for_conflict_warning = resolved_full_action or resolved_action
        if command_for_conflict_warning:
            _report_sync_messages(
                _wrapper_conflict_warnings_for_command(db, command_for_conflict_warning)
            )

    if normalized_action == 'sync':
        is_uninstall = "--uninstall" in sys.argv
        if not is_uninstall:
            _warn("Manual sync is no longer required. Wrappers are synced automatically.")
        sync_errors = sync_binaries(db, uninstall=is_uninstall)
        if _report_sync_messages(sync_errors):
            sys.exit(1)
        if not is_uninstall:
            _ok("Automatic wrapper sync complete.")
        return

    if resolved_full_action:
        exec_cmd(resolved_full_action, db[resolved_full_action])
        return

    if normalized_action in ('-h', '--help'):
        p.print_help()

    elif normalized_action in ('update', 'upd'):
        _auto_update()

    elif normalized_action in ('ls', 'list'):
        print_list(db)

    elif normalized_action == 'hook':
        target_dir = _script_bin_dir(os.name)
        wrappers, wrapper_errors, _ = _build_wrapper_map_with_conflicts(db, target_dir)
        _report_sync_messages(wrapper_errors)
        if os.name == 'nt':
            print(f'doskey {SHORT_ALIAS}={PRIMARY_WRAPPER} $*')
            print(f'doskey {LEGACY_ALIAS}={PRIMARY_WRAPPER} $*')
            for wrapper_name, command_name in sorted(wrappers.items()):
                print(f'doskey {wrapper_name}={PRIMARY_WRAPPER} {_cmd_quote(command_name)} $*')
        else:
            print(f"alias {SHORT_ALIAS}='{PRIMARY_WRAPPER}'")
            print(f"alias {LEGACY_ALIAS}='{PRIMARY_WRAPPER}'")
            for wrapper_name, command_name in sorted(wrappers.items()):
                quoted_command = shlex.quote(command_name)
                print(f"alias {wrapper_name}=\"{PRIMARY_WRAPPER} {quoted_command}\"")

    elif normalized_action in ('configure', 'config'):
        run_wizard()

    elif normalized_action == 'add':
        _filtered_argv, has_yaml_flag = _strip_add_yaml_flag([PRIMARY_WRAPPER, *action_parts])
        if not has_yaml_flag:
            _error(f"Usage: {PRIMARY_WRAPPER} add --yaml <<EOF\\n...\\nEOF")
            sys.exit(1)
        yaml_content = sys.stdin.read()
        if not yaml_content.strip():
            _error("No YAML content on stdin.")
            sys.exit(1)
        cmd_add_yaml(yaml_content)

    elif normalized_action in ('rm', 'remove'):
        if len(action_parts) < 2:
            _error(f"Usage: {PRIMARY_WRAPPER} {action} <name>")
            sys.exit(1)

        name = " ".join(action_parts[1:])
        resolved_name = _resolve_command_name(name, db, lookup_index)
        if not resolved_name:
            _error(f"'{name}' not found")
            sys.exit(1)

        removed, err_message, sync_messages = remove_from_file(resolved_name, db[resolved_name]['_source'])
        if not removed:
            _error(err_message)
            sys.exit(1)

        has_sync_errors = _report_sync_messages(sync_messages)
        if has_sync_errors:
            sys.exit(1)

        _ok(f"Removed '{resolved_name}'.")

    else:
        target = resolved_full_action or resolved_action
        if target:
            exec_cmd(target, db[target])
        else:
            _error(f"'{full_action}' not found")
            sys.exit(1)


if __name__ == "__main__":
    main()
