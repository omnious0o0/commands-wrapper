#!/usr/bin/env python3
import os
import sys
import time
import argparse
import yaml
import pexpect
from typing import Dict, List, Any, Optional

class Parser(argparse.ArgumentParser):
    def exit(self, status=0, message=None):
        if message: self._print_message(message, sys.stderr)
        os._exit(status)

def find_yamls() -> List[str]:
    roots = [os.getcwd()]
    try:
        proj_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        if proj_root not in roots: roots.append(proj_root)
    except: pass
    
    found = []
    for r in roots:
        paths = [os.path.join(r, 'commands.yaml'), os.path.join(r, 'commands.yml')]
        for d in ('.commands-wrapper', 'commands-wrapper'):
            tgt = os.path.join(r, d)
            if os.path.isdir(tgt):
                try:
                    paths.extend(os.path.join(tgt, f) for f in os.listdir(tgt) if f.endswith(('.yaml', '.yml')) and not f.startswith('.'))
                except PermissionError: pass
        found.extend([p for p in set(paths) if os.path.isfile(p)])
    return list(set(found))

def load_cmds(files: List[str]) -> Dict[str, Any]:
    cmds = {}
    for f in files:
        try:
            with open(f) as stream:
                data = yaml.safe_load(stream)
                if not isinstance(data, dict): continue
                for k, v in data.items():
                    if isinstance(v, dict) and any(str(x).startswith('steps') for x in v):
                        cmds[k] = v
        except: pass
    return cmds

def run_step(proc: Optional[pexpect.spawn], ctx: Dict[str, Any], timeout: Optional[int]) -> Optional[pexpect.spawn]:
    if 'command' in ctx:
        if proc and proc.isalive():
            proc.logfile_read = None
            try: proc.interact()
            except: pass
            proc.close()
        print(f"\n---> {ctx['command']}")
        proc = pexpect.spawn(os.environ.get('SHELL', 'sh'), ['-c', ctx['command']], encoding='utf-8', timeout=timeout)
        proc.logfile_read = sys.stdout
    elif 'send' in ctx and proc:
        proc.sendline(str(ctx['send']))
    elif 'press_key' in ctx and proc:
        k = str(ctx['press_key']).lower()
        if k in ('enter', 'return'): proc.sendline()
        elif k == 'tab': proc.send('\t')
        elif k in ('esc', 'escape'): proc.send('\x1b')
        else: proc.send(k)
    elif 'wait' in ctx:
        time.sleep(float(ctx['wait']))
    return proc

def exec_cmd(name: str, cfg: Dict[str, Any]) -> None:
    key = next((k for k in cfg if str(k).startswith('steps')), None)
    if not key: return
    t = int(str(key).split()[1]) if len(str(key).split()) > 1 else None
    proc = None
    for s in cfg[key]: proc = run_step(proc, s, t)
    if proc and proc.isalive():
        proc.logfile_read = None
        try: proc.interact()
        except: pass
        proc.close()

def main():
    p = Parser(description="commands-wrapper automation engine.")
    p.add_argument("action", nargs=argparse.REMAINDER)
    args = p.parse_args()
    if not args.action or args.action[0] in ('-h', '--help'):
        p.print_help()
        os._exit(0 if args.action else 1)
    
    cmd = " ".join(args.action)
    db = load_cmds(find_yamls())
    
    if cmd in ('ls', 'list'):
        for k, v in db.items():
            print(f"\n# {'-'*22} {k} {'-'*22}\n# {v.get('description', '')}\n# {'-'*(46+len(k))}")
    elif cmd in db:
        exec_cmd(cmd, db[cmd])
    else:
        sys.stderr.write(f"Error: '{cmd}' not found.\n")
        os._exit(1)

if __name__ == "__main__":
    main()
